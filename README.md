# Axa CPU

This repo contains software for my CPU architecture called Axa.

## The software

The directory `src` contains the `axa` program, which featuers the following:

* An assembler for the Axa assembly language
* An emulator which can execute Axa machine code
* A compiler for the Ax programming language

Compile the program with `cargo build`. Here's how to use it:

```
Usage: target/debug/axa [options] <input-file>

Options:
  -o <file>:   Write result to <file>
  --print-asm: Print annotated assembly code when compiling ax files
  --run:       Run the emulator on the input file
  --step:      Step through in the emulator
  --hz <hz>:   Run emulator at <hz> Hz
```

So to assemble some assembly code to machine code, you would run:

	axa -o my-program my-program.s

Or to compile an ax source file:

	axa -o my-fancy-program my-fancy-program.ax

To run the emulator on `my-program`:

	axa --run my-program

There's also a `--step` option to step through instruction
by instruction, and a `--hz <hz>` option to set the speed
of the emulator in hertz (the default is 20Hz).

It will automatically compile or assemble input source code if asked to emulate:

	axa --run my-fancy-program.ax
	axa --run my-program.s

You can even ask it to compile an ax program to assembly:

	axa -o my-fancy-program.s my-fancy-program.ax

Or, for debugging purposes, you can get it to print
annotated assembly code generated by the compiler:

	axa --print-asm my-fancy-program.ax

## Example code

There's some examples in the `examples` directory:

* [collatz.ax](examples/collatz.ax): An implementation of [the Collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)

## The Axa architecture

Axa is an 8-bit accumulator-based architecture.
It can address up to 2^16 bytes using segmented memory,
and its instructions are constand-width 1-byte.

There are four instruction formats: R-type, I-type, M-type and J-type.
They all start with a 4-bit op-code.

### R-type instructions

R-type instructions are "regular" instructions which operate on two values.
They are formatted like this:

Format R:
| Bits 0-3 | Bit 4 | Bits 5-7 |
|----------|-------|----------|
| OpCode   | DBit  | Reg      |

R-type instructions are some form of: `D = D <OP> S`.
`D` and `S` are given by the `DBit`. If `DBit` is 0, S is the accumulator and D
is the register given by `Reg`. If `DBit` is 1, S is the register and D is the
accumulator.

| DBit | Expression       |
|------|------------------|
| 0    | Reg = Reg OP Acc |
| 1    | Acc = Acc OP Reg |

Here are all the R-type instructions:

| OpCode | Mnemonic | Expression  | Note                                            |
|--------|----------|-------------|-------------------------------------------------|
| 0000   | ADD      | D = D + S   |                                                 |
| 0001   | SUB      | D = D - S   |                                                 |
| 0010   | XOR      | D = D XOR S |                                                 |
| 0011   | AND      | D = D AND S |                                                 |
| 0100   | OR       | D = D OR S  |                                                 |
| 0101   | MOV      | D = S       |                                                 |
| 0110   | SHR      | D = S >> 1  |                                                 |
| 0111   | CMP      | _ = D - S   | No value is written, only flags                 |
| 1000   | ADDC     | D = D + S   | ADD but with cin from carry flag                |
| 1001   | SHRC     | D = S >> 1  | SHR but with the shifted-in bit from carry flag |
| 1010   | CMPC     | _ = D - S   | CMP but with cin from carry flag                |

### J-type instructions

There is only one J-type instruction. It's formatted like this:

Format J:
| Bits 0-3 | Bit 4 | Bits 5-7 |
|----------|-------|----------|
| 1011     | SBit  | JumpOp   |

The `JmpOp` is a 3-bit code which describes what kind of jump it is.
There are two kinds of jumps: absolute and relative.

The absolute jumps will jump to a 16-bit address, taking their low 8 bits from
the accumulator and their high 8 bits from the Code Segment (CS) register.
The two absolute jump instructions are:

| JumpOp | Mnemonic | Explanation                            |
|--------|----------|----------------------------------------|
| 000    | JMP      | Jump to (CS << 8) \| Acc               |
| 001    | CALL     | Put the return address in RA, then JMP |

The relative jumps are called branches.
They treat the accumulator as an 8-bit signed value
and add it to the program counter. There are 6 kinds of branches:

| JumpOp | Mnemonic | Branch condition                                             |
|--------|----------|--------------------------------------------------------------|
| 010    | B        | Unconditional                                                |
| 011    | BEQ      | The zero flag is set                                         |
| 100    | BGT      | The carry flag is set and the zero flag is not set           |
| 101    | BGE      | The carry flag is set                                        |
| 110    | BGTS     | The signed overflow flag is set and the zero flag is not set |
| 111    | BGES     | The signed overflow flag is set                              |

To make short relative backwards branches more space efficient,
the high 4 bits of the relative offset will all be set to 1 if the `SBit` is set.
This allows for a 5-bit signed relative jump to be encoded with one IMML instruction
followed by one branch instruction. (More on IMML and IMMH in the I-type section)

### M-type instructions

The M-type instructions are the load and store instructions. They are formatted like this:

Format M:
| Bits 0-3 | Bit 4 | Bits 5-7 |
|----------|-------|----------|
| OpCode   | DBit  | Reg      |

The memory instructions are:

| OpCode | Mnemonic |                            |
|--------|----------|----------------------------|
| 1100   | LD       | Load from RAM to register  |
| 1101   | ST       | Store from register to RAM |

These instructions read from or write to the register specified by `Reg`.
If `DBit` is 0, the RAM address that's loaded from or stored to is the
8-bit value in the accumulator. If `DBit` is 1, the address is a 16-bit value,
taking its low 8 bits from the accumulator and its high 8 bits from
the Data Segment (DS) register.

So to load from address `0x00c3`, you would set the accumulator to `0xc3` and
execute `LD` with `DBit` set to 0. To load from address `0xa3f7`, you would
set the `DS` register to `0xa3` and the accumulator to `0xf7` and then execute
`LD` with `DBit` set to 1.

### I-type instructions

The I-type instructions are the immediate instructions, which exist to get
an immediate value into the accumulator.
They are formatted like this:

Format I:
| Bits 0-3 | Bits 4-7  |
|----------|-----------|
| OpCode   | Immediate |

The immediate instructions are:

| OpCode | Mnemonic | Expression                      |
|--------|----------|---------------------------------|
| 1110   | IMML     | Accumulator = Immediate         |
| 1111   | IMMH     | Accumulator |= (Immediate << 4) |

The `IMML` instruction clears the entire accumulator and then sets the low 4 bits
to the `Immediate` value from the instruction.
The `IMMH` instruction clears the upper 4 bits of the accumulator and then sets
the high 4 bits to the `Immediate` value from the instruction.
That means any 8-bit immediate can be encoded as an `IMML` instruction
followed by an `IMMH` instruction, and a 4-bit immediate can be encoded as a single
`IMML` instruction.
